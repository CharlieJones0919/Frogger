#include "TextObject.h"
#include "GroundTile.h"
#include "EnemyOrPlatform.h"
#include "Frog.h"
// ^ Inclusion of object headers. (SpriteObject already contains <SFML/Graphics.hpp>, <iostream>, namespace std and namespace sf).

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// REQUIRED MEMORY AND OBJECTS ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// REQUIRED MEMORY AND OBJECTS ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

sf::Vector2i const windowDimensions = Vector2i(900, 950); // Dimensions for the Window. (Wanted to make the game scalable to window size but ran out of time).
sf::RenderWindow window(sf::VideoMode(windowDimensions.x, windowDimensions.y), "Frogger Game (P2423910)"); // Game Window using above dimensions.

sf::Event event; // Event definition.

unsigned int const objectPositionsX = 10; // Specifies the number of enemies and platforms to each row. (Must be at least 10 for the ground tiles to cover the screen).
unsigned int const objectPositionsY = 15; // Number of game object rows.

bool playerDied; 
bool hasCollidedInThisLoop; // Used because due to objectPositionsX being modular, some objects with large inbetween gaps or sprite sizes can overlap ontop of eachother and thus when the player hits them they'll hurt the frog multiple times instead of once. Used so only one object can trigger per loop.

unsigned int levelDifficulty; 
unsigned int scoreValue;

TextObject messageLabel, scoreLabel, levelTimeLabel, livesLabel, stageLabel; // The text objects used to output game values in the window.
bool messageBeenShown; // Used so the death and winning messages/text are only shown for a period of time and now indefinitely.

sf::Clock levelTimer; 
sf::Time elapsedLevelTime;
unsigned int levelTimeLimitMins, levelTimeLimitSecs, levelTimeRemainingMins, levelTimeRemainingSecs; // First 2 store the starting time values and the second 2 store the remainder of those values in minutes and seconds.

sf::Clock animationTimer; 
sf::Time animationTimeElapsed; 
// ^ Used for the Frog's death animation.

Frog playerFrog; // Player object as defined in Frog.h and Frog.cpp.

GroundTile groundTile; // Making a ground tile.
GroundTile groundTileList[objectPositionsX][objectPositionsY]; // An array for each values to be set to the created ground tile making an individual tile for every column and row of the game screen. This is done so the ground can dynamically be set a type, sprite and position depending on what the enemy objects on each row.

EnemyOrPlatform enemyOrPlatform; 
EnemyOrPlatform enemyOrPlatList[objectPositionsX][objectPositionsY];
sf::String enemiesOrPlatsOnMap[objectPositionsY] = { "inCrocodile", "pLog", "pTurtle",  " ", "Car", "Lorry", "Race Kart", "Snake", "Race Kart 2.0", "Race Kart 3.0", "inCrocodile", "pLog", "pTurtle", "pLog", " " }; // The enemies on each row from top to bottom as an array of strings. 
// ^ As moving objects the enemy and platoform object is interchangable depending of what the obejct name is for reusablility. (If the first character of the name is a 'p' it's a platform and the player won't be hurt by touching it).

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// FUNCTIONS ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// FUNCTIONS ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void resetGameValues(); // Initialises changing game values like the time, score and player lives back to their starting states;
void createGroundAndNonPlayerObjects();  // The loop used to create the ground tiles, platforms and enemies.

void levelTimeKeeping();

void movementInput(); // Checks for movement related keyboard input.

void gameScreen();
void detectAndDrawGroundTiles(); // Draws the ground tiles to the window and checks if the player is interacting/intersecting with eventful ones like Water or the Winning Ground.
void detectAndDrawEnemiesAndPlats(); // Same as above, draws and checks for interactions with moving non-player objects.

void frogDeathAnimation();

//////////////////////////////////////////////////////////////////////////////////////// MAIN() FUNCTION //////////////////////////////////////////////////////////////////////////////////////// MAIN() FUNCTION //////////////////////////////////////////////////////////////////////////////////////// MAIN() FUNCTION //////////////////////////////////////////////////////////////////////////////////////// MAIN() FUNCTION ////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// MAIN() FUNCTION //////////////////////////////////////////////////////////////////////////////////////// MAIN() FUNCTION //////////////////////////////////////////////////////////////////////////////////////// MAIN() FUNCTION //////////////////////////////////////////////////////////////////////////////////////// MAIN() FUNCTION ////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// MAIN() FUNCTION //////////////////////////////////////////////////////////////////////////////////////// MAIN() FUNCTION //////////////////////////////////////////////////////////////////////////////////////// MAIN() FUNCTION //////////////////////////////////////////////////////////////////////////////////////// MAIN() FUNCTION ////////////////////////////////////////////////////////////////////////////////////////

int main()
{
	// Setting text properties.
	messageBeenShown = true;
	messageLabel.setTextPosition(Vector2f(0 + (windowDimensions.x * 0.35f), 0 + (windowDimensions.y * 0.03f)));
	messageLabel.changeTextColour(sf::Color::White);
	messageLabel.changeTextFont("Assets/Fonts/Batter-Up-Outline.ttf");

	scoreLabel.setTextPosition(Vector2f(0 + (windowDimensions.x * 0.015f), 0 + (windowDimensions.y * 0.0075f)));
	levelTimeLabel.setTextPosition(Vector2f(0 + (windowDimensions.x * 0.015f), 0 + (windowDimensions.y * 0.05f)));
	livesLabel.setTextPosition(Vector2f(windowDimensions.x - (windowDimensions.x * 0.175f), 0 + (windowDimensions.y * 0.0075f)));
	stageLabel.setTextPosition(Vector2f(windowDimensions.x - (windowDimensions.x * 0.175f), 0 + (windowDimensions.y * 0.05f)));

	// Getting window dimensions for each object.
	playerFrog.getWindowSize(Vector2i(windowDimensions.x, windowDimensions.y - (windowDimensions.y * 0.05f)));
	groundTile.getWindowSize(Vector2i(windowDimensions.x, windowDimensions.y - (windowDimensions.y * 0.05f)));
	enemyOrPlatform.getWindowSize(Vector2i(windowDimensions.x, windowDimensions.y - (windowDimensions.y * 0.05f)));

	// Setting level time limit.
	levelTimeLimitMins = 5;
	levelTimeLimitSecs = 0;
 
	// Initalise game.
	resetGameValues();

	// Open window and start loop.
	while (window.isOpen())
	{
		while (window.pollEvent(event)) // Checking for user input.
		{
			movementInput(); 

			if (event.type == sf::Event::Closed) // When user closes window close the window.
			{
				window.close();
			}
		}

		levelTimeKeeping();

		if (playerFrog.getRemainingLives() <= 0) // When player is out of lives reset the game values, set the player's lives back to 3, and set the messageBeenShown bool to false to show the death message.
		{
			playerFrog.setLives(3);

			resetGameValues();
			messageBeenShown = false;
		}
		

		if (scoreValue >= 5000) // There are 10 Winning ground tiles which each add 500 to scoreValues when the player gets to them thus completing the game. This shows the game won end screen for 2 seconds before closing the application.
		{
			messageBeenShown = false; // To make the level timer switch to the message shown if statement.

			if (elapsedLevelTime.asSeconds() < 2.0f) 
			{
				window.clear(sf::Color::White);
				messageLabel.changeTextColour(sf::Color::Black);
				window.draw(messageLabel.setAndGetText("You Won!"));
				window.display();
			}
			else
			{
				window.close();
			}
		}
		else
		{
			gameScreen(); // If the score is less than 5000 (e.g. they haven't triggered all the winning tiles), run the gameScreen().
		}
	}

	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////// INITIALISE GAME VALUES //////////////////////////////////////////////////////////////////////////////////////// INITIALISE GAME VALUES //////////////////////////////////////////////////////////////////////////////////////// INITIALISE GAME VALUES //////////////////////////////////////////////////////////////////////////////////////// INITIALISE GAME VALUES ////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// INITIALISE GAME VALUES //////////////////////////////////////////////////////////////////////////////////////// INITIALISE GAME VALUES //////////////////////////////////////////////////////////////////////////////////////// INITIALISE GAME VALUES //////////////////////////////////////////////////////////////////////////////////////// INITIALISE GAME VALUES ////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// INITIALISE GAME VALUES //////////////////////////////////////////////////////////////////////////////////////// INITIALISE GAME VALUES //////////////////////////////////////////////////////////////////////////////////////// INITIALISE GAME VALUES //////////////////////////////////////////////////////////////////////////////////////// INITIALISE GAME VALUES ////////////////////////////////////////////////////////////////////////////////////////

void resetGameValues()
{
	levelDifficulty = 1;
	scoreValue = 0;

	levelTimeRemainingMins = levelTimeLimitMins;
	levelTimeRemainingSecs = levelTimeLimitSecs;

	playerDied = false;
	hasCollidedInThisLoop = false;

	playerFrog.setFrogProperties();
	createGroundAndNonPlayerObjects();
}


//////////////////////////////////////////////////////////////////////////////////////// CREATE NON-PLAYER OBJECTS //////////////////////////////////////////////////////////////////////////////////////// CREATE NON-PLAYER OBJECTS //////////////////////////////////////////////////////////////////////////////////////// CREATE NON-PLAYER OBJECTS //////////////////////////////////////////////////////////////////////////////////////// CREATE NON-PLAYER OBJECTS////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// CREATE NON-PLAYER OBJECTS //////////////////////////////////////////////////////////////////////////////////////// CREATE NON-PLAYER OBJECTS //////////////////////////////////////////////////////////////////////////////////////// CREATE NON-PLAYER OBJECTS //////////////////////////////////////////////////////////////////////////////////////// CREATE NON-PLAYER OBJECTS////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// CREATE NON-PLAYER OBJECTS //////////////////////////////////////////////////////////////////////////////////////// CREATE NON-PLAYER OBJECTS //////////////////////////////////////////////////////////////////////////////////////// CREATE NON-PLAYER OBJECTS //////////////////////////////////////////////////////////////////////////////////////// CREATE NON-PLAYER OBJECTS////////////////////////////////////////////////////////////////////////////////////////

void createGroundAndNonPlayerObjects() // By create I mean setting the individual properties to each object.
{
	char enemyOrPlatFirstCharLast = 'x'; // First character of last defined object's name. (Placeholder). 
	char enemyOrPlatFirstCharCurrent = ' '; // First character of most recently defined object's name. (Placeholder). 
	// ^ Used to determine if the object has changed since the last loop.

	sf::String directionToFaceEnemyOrPlat = "Left"; // Direction to direct moving object. 
	int numOfSameRowObjects = 0; 

	for (int downCounter = 0; downCounter < objectPositionsY; downCounter++) // Looping through the object array's columns and rows one at a time.
	{
		for (int acrossCounter = 0; acrossCounter < objectPositionsX; acrossCounter++)
		{
			//////////////////////////////////////////////////////////////////////////////////////// CREATE ENEMIES AND PLATFORMS ////////////////////////////////////////////////////////////////////////////////////////
			if (enemiesOrPlatsOnMap[downCounter] != " ") // Only set properties if an enemy/platform has been allocated to the row.
			{
				enemyOrPlatList[acrossCounter][downCounter] = enemyOrPlatform; // Sets array values to created EnemyOrPlatform object.

				enemyOrPlatFirstCharCurrent = enemiesOrPlatsOnMap[downCounter][0]; // Set current object name's first character to the character of the current array object's string name.

				if (enemyOrPlatFirstCharLast != enemyOrPlatFirstCharCurrent) // Only run if object has changed. (Current object char different to last objects').
				{
					if ((enemyOrPlatFirstCharLast == 'i') && (enemyOrPlatFirstCharCurrent == 'p')) 
					{
						numOfSameRowObjects++;
						// The crocodiles go on the same line as the logs thus an 'i' was added to the start of its name so that if it goes before a platform, all the proceeding object's row increments will be subtracted by 1 so they'll be moved one line up.
					}

					if (enemyOrPlatFirstCharLast != 'i') // If first character of object has changed swap the next object's direction.
					{
						if (directionToFaceEnemyOrPlat == "Left") 
						{
							directionToFaceEnemyOrPlat = "Right";
						}
						else if (directionToFaceEnemyOrPlat == "Right")
						{
							directionToFaceEnemyOrPlat = "Left";
						}
					}
				}

				enemyOrPlatList[acrossCounter][downCounter].setNonPlayerProperties(enemiesOrPlatsOnMap[downCounter]); 
				enemyOrPlatList[acrossCounter][downCounter].setMovingObjectProperties(Vector2f(acrossCounter, (downCounter - numOfSameRowObjects) + 3), directionToFaceEnemyOrPlat);
				enemyOrPlatFirstCharLast = enemiesOrPlatsOnMap[downCounter][0];
			}

			//////////////////////////////////////////////////////////////////////////////////////// CREATE GROUND TILES ////////////////////////////////////////////////////////////////////////////////////////
			groundTileList[acrossCounter][downCounter] = groundTile;
			if (downCounter == 0)
			{
				groundTileList[acrossCounter][downCounter].setNonPlayerProperties("Won Grass"); // First/top row tiles are always winning tiles.
				groundTileList[acrossCounter][downCounter].setTilePosition(acrossCounter, (downCounter + 2));
			}
			else
			{
				if ((enemiesOrPlatsOnMap[downCounter] == " ") || (enemiesOrPlatsOnMap[downCounter] == "Snake"))
				{
					groundTileList[acrossCounter][downCounter].setNonPlayerProperties("Safe Grass");
				}
				else if ((enemiesOrPlatsOnMap[downCounter] == "pLog") || (enemiesOrPlatsOnMap[downCounter] == "pTurtle"))
				{
					groundTileList[acrossCounter][downCounter].setNonPlayerProperties("Water");
				}
				groundTileList[acrossCounter][downCounter].setTilePosition(acrossCounter, ((downCounter - numOfSameRowObjects) + 3));
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////// TIME KEEPING //////////////////////////////////////////////////////////////////////////////////////// TIME KEEPING //////////////////////////////////////////////////////////////////////////////////////// TIME KEEPING //////////////////////////////////////////////////////////////////////////////////////// TIME KEEPING //////////////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////////////// TIME KEEPING //////////////////////////////////////////////////////////////////////////////////////// TIME KEEPING //////////////////////////////////////////////////////////////////////////////////////// TIME KEEPING //////////////////////////////////////////////////////////////////////////////////////// TIME KEEPING ////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// TIME KEEPING //////////////////////////////////////////////////////////////////////////////////////// TIME KEEPING //////////////////////////////////////////////////////////////////////////////////////// TIME KEEPING //////////////////////////////////////////////////////////////////////////////////////// TIME KEEPING ////////////////////////////////////////////////////////////////////////////////////////

void levelTimeKeeping()
{
	elapsedLevelTime = levelTimer.getElapsedTime();

	if (messageBeenShown == false)
	{
		if (elapsedLevelTime.asSeconds() > 2.0f) // Unsets message display after 2 seconds.
		{
			messageBeenShown = true;
			levelTimer.restart();
		}
	}
	else
	{
		if ((levelTimeRemainingMins == 0) && (levelTimeRemainingSecs == 0)) // If time has run out, reset timer and other game values then kill player.
		{
			levelTimeRemainingMins = levelTimeLimitMins;
			levelTimeRemainingSecs = levelTimeLimitSecs;
			levelTimeLabel.revertTextColour();

			levelDifficulty = 1;
			scoreValue = 0;


			for (int downCounter = 0; downCounter < objectPositionsY; downCounter++)
			{
				for (int acrossCounter = 0; acrossCounter < objectPositionsX; acrossCounter++)
				{
					groundTileList[acrossCounter][downCounter].unsetWinningBox();
				}
			}
			playerFrog.setLives(1);
			playerDied = true;
		}
		else if (elapsedLevelTime.asSeconds() > 1) // Keeping minutes and seconds.
		{
			if ((levelTimeRemainingSecs == 0) && (levelTimeRemainingMins > 0))
			{
				levelTimeRemainingSecs = 59;
				levelTimeRemainingMins--;
			}

			if (levelTimeRemainingMins == 0)
			{
				levelTimeLabel.changeTextColour(sf::Color::Red);
			}

			levelTimeRemainingSecs--;
			levelTimer.restart();
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////// MOVEMENT INPUT //////////////////////////////////////////////////////////////////////////////////////// MOVEMENT INPUT //////////////////////////////////////////////////////////////////////////////////////// MOVEMENT INPUT //////////////////////////////////////////////////////////////////////////////////////// MOVEMENT INPUT //////////////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////////////// MOVEMENT INPUT //////////////////////////////////////////////////////////////////////////////////////// MOVEMENT INPUT //////////////////////////////////////////////////////////////////////////////////////// MOVEMENT INPUT //////////////////////////////////////////////////////////////////////////////////////// MOVEMENT INPUT ////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// MOVEMENT INPUT //////////////////////////////////////////////////////////////////////////////////////// MOVEMENT INPUT //////////////////////////////////////////////////////////////////////////////////////// MOVEMENT INPUT //////////////////////////////////////////////////////////////////////////////////////// MOVEMENT INPUT ////////////////////////////////////////////////////////////////////////////////////////

void movementInput()
{
	if (playerFrog.getIsDying() == false) // Get input from arrow keys and WASD for movement.
	{
		if (event.type == sf::Event::KeyPressed)
		{
			if ((event.key.code == sf::Keyboard::Up) || (event.key.code == sf::Keyboard::W))
			{
				playerFrog.movement("Up");
			}
			else if ((event.key.code == sf::Keyboard::Left) || (event.key.code == sf::Keyboard::A))
			{
				playerFrog.movement("Left");
			}
			else if ((event.key.code == sf::Keyboard::Down) || (event.key.code == sf::Keyboard::S))
			{
				playerFrog.movement("Down");
			}
			else if ((event.key.code == sf::Keyboard::Right) || (event.key.code == sf::Keyboard::D))
			{
				playerFrog.movement("Right");
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////// GAME SCREEN //////////////////////////////////////////////////////////////////////////////////////// GAME SCREEN //////////////////////////////////////////////////////////////////////////////////////// GAME SCREEN //////////////////////////////////////////////////////////////////////////////////////// GAME SCREEN ////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// GAME SCREEN //////////////////////////////////////////////////////////////////////////////////////// GAME SCREEN //////////////////////////////////////////////////////////////////////////////////////// GAME SCREEN //////////////////////////////////////////////////////////////////////////////////////// GAME SCREEN ////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// GAME SCREEN //////////////////////////////////////////////////////////////////////////////////////// GAME SCREEN //////////////////////////////////////////////////////////////////////////////////////// GAME SCREEN //////////////////////////////////////////////////////////////////////////////////////// GAME SCREEN ////////////////////////////////////////////////////////////////////////////////////////

void gameScreen()
{
	window.clear(sf::Color::Black);

	detectAndDrawGroundTiles();
	detectAndDrawEnemiesAndPlats();

	if (playerDied == true)
	{
		playerFrog.hasBeenHurt(1);
		playerDied = false;
	}

	frogDeathAnimation(); // Only actually execute animation if playerDied = true.

	window.draw(playerFrog.getSprite()); // Draw Frog to screen.

	if (messageBeenShown == false)
	{
		window.draw(messageLabel.setAndGetText("YOU DIED")); // Death message triggered when out of lives.
	}

	window.draw(scoreLabel.setAndGetText("SCORE " + to_string(scoreValue)));
	window.draw(levelTimeLabel.setAndGetText("TIME " + to_string(levelTimeRemainingMins) + ":" + to_string(levelTimeRemainingSecs)));
	window.draw(livesLabel.setAndGetText("LIVES " + to_string(playerFrog.getRemainingLives())));
	window.draw(stageLabel.setAndGetText("STAGE " + to_string(levelDifficulty)));
	// Output game values to text objects.

	window.display();
}

//////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW GROUND //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW GROUND //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW GROUND //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW GROUND ////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW GROUND //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW GROUND //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW GROUND //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW GROUND ////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW GROUND //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW GROUND //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW GROUND //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW GROUND ////////////////////////////////////////////////////////////////////////////////////////

void detectAndDrawGroundTiles()
{
	for (int downCounter = 0; downCounter < objectPositionsY; downCounter++)
	{
		for (int acrossCounter = 0; acrossCounter < objectPositionsX; acrossCounter++)
		{
			window.draw(groundTileList[acrossCounter][downCounter].getSprite()); // Draw ground tiles.

			if (playerFrog.getIsDying() == false)
			{
				if (playerFrog.getBoundingBox().intersects(groundTileList[acrossCounter][downCounter].getBoundingBox()) && (groundTileList[acrossCounter][downCounter].getGroundType() == "Water")) // If player touches water tile, playerDied is set to true.
				{
					playerDied = true;
				}

				if (playerFrog.getBoundingBox().intersects(groundTileList[acrossCounter][0].getBoundingBox()) && (groundTileList[acrossCounter][downCounter].getGroundType() == "Won Grass") && (groundTileList[acrossCounter][0].getWinningBoxHasBeenTriggered() == false))
				{
					groundTileList[acrossCounter][downCounter].setWinningBox(); // Changes object's sprite to triggered winning tile if the player has intersected it.
					levelDifficulty++; 
					scoreValue += 500;
					playerFrog.setFrogProperties();

					for (int downCounter = 0; downCounter < objectPositionsY; downCounter++)
					{
						for (int acrossCounter = 0; acrossCounter < objectPositionsX; acrossCounter++)
						{
							enemyOrPlatList[acrossCounter][downCounter].setMovementSpeedToDifficulty(levelDifficulty); // Increase speed of all tiles when player has touched winning tile.
						}
					}
				}
				else if (playerFrog.getBoundingBox().intersects(groundTileList[acrossCounter][0].getBoundingBox()) && (groundTileList[acrossCounter][downCounter].getGroundType() == "Won Grass") && (groundTileList[acrossCounter][0].getWinningBoxHasBeenTriggered() == true))
				{
					playerDied = true; // Player dies if they touch winning tile that has already been triggered.
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW ENEMIES AND PLATFORMS //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW ENEMIES AND PLATFORMS //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW ENEMIES AND PLATFORMS ////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW ENEMIES AND PLATFORMS //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW ENEMIES AND PLATFORMS //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW ENEMIES AND PLATFORMS ////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW ENEMIES AND PLATFORMS //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW ENEMIES AND PLATFORMS //////////////////////////////////////////////////////////////////////////////////////// DETECT AND DRAW ENEMIES AND PLATFORMS ////////////////////////////////////////////////////////////////////////////////////////

void detectAndDrawEnemiesAndPlats()
{
	for (int downCounter = 0; downCounter < objectPositionsY; downCounter++)
	{
		for (int acrossCounter = 0; acrossCounter < objectPositionsX; acrossCounter++)
		{
			if (enemiesOrPlatsOnMap[downCounter] != " ")
			{
				window.draw(enemyOrPlatList[acrossCounter][downCounter].getSprite());

				if (playerFrog.getIsDying() == false)
				{
					enemyOrPlatList[acrossCounter][downCounter].movement(); // Move objects.

					if ((playerFrog.getBoundingBox().intersects(enemyOrPlatList[acrossCounter][downCounter].getBoundingBox())) && (enemyOrPlatList[acrossCounter][downCounter].getMovingPlatformStatus() == false))
					{
						playerFrog.hasBeenHurt(1); // If moving object isn't a platform player loses a life for touching it.
					}

					if ((enemyOrPlatList[acrossCounter][downCounter].getBoundingBox().intersects(playerFrog.getBoundingBox())) && (enemyOrPlatList[acrossCounter][downCounter].getMovingPlatformStatus() == true) && (hasCollidedInThisLoop == false))
					{
						playerFrog.isOnPlatform(enemyOrPlatList[acrossCounter][downCounter].getPlatformSpeed(), enemyOrPlatList[acrossCounter][downCounter].getPlatformDirection()); // Move in direction and speed of platform if on top of.
						hasCollidedInThisLoop = true; // Player already touched object in this loop.
						playerDied = false; // If player is on a platform unset the playerDied bool which would have been set to true if they're on the water. Will stay true if they aren't on a platform.
					}
				}
			}
		}
	}
	hasCollidedInThisLoop = false; // Unsets bool for next loop.
}

//////////////////////////////////////////////////////////////////////////////////////// FROG DEATH ANIMATION //////////////////////////////////////////////////////////////////////////////////////// FROG DEATH ANIMATION //////////////////////////////////////////////////////////////////////////////////////// FROG DEATH ANIMATION //////////////////////////////////////////////////////////////////////////////////////// FROG DEATH ANIMATION //////////////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////////////// FROG DEATH ANIMATION //////////////////////////////////////////////////////////////////////////////////////// FROG DEATH ANIMATION //////////////////////////////////////////////////////////////////////////////////////// FROG DEATH ANIMATION //////////////////////////////////////////////////////////////////////////////////////// FROG DEATH ANIMATION //////////////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////////////// FROG DEATH ANIMATION //////////////////////////////////////////////////////////////////////////////////////// FROG DEATH ANIMATION //////////////////////////////////////////////////////////////////////////////////////// FROG DEATH ANIMATION //////////////////////////////////////////////////////////////////////////////////////// FROG DEATH ANIMATION //////////////////////////////////////////////////////////////////////////////////////// 

void frogDeathAnimation()
{
	animationTimeElapsed = animationTimer.getElapsedTime();

	if (playerFrog.getIsDying() == true)
	{
		if (animationTimeElapsed.asSeconds() > 0.5f)
		{
			playerFrog.changeSprites();
			animationTimer.restart();
		}
	}
	else if (animationTimeElapsed.asSeconds() > 10.0f)
	{
		animationTimer.restart();
	}
}

// Remember Relative Directory Routing:
// $(SolutionDir)/./External Libraries/SFML/include